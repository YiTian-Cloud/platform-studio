import { FileTree, addFile, createEmptyTree } from "./fileTree";
import { ServiceSpec } from "./types";

export function baseServiceTemplate(spec: ServiceSpec): FileTree {
  let tree = createEmptyTree();

  const name = spec.serviceName;
  const description = spec.purpose || `${name} service`;

  // package.json
  tree = addFile(
    tree,
    "package.json",
    JSON.stringify(
      {
        name,
        version: "1.0.0",
        private: true,
        main: "dist/index.js",
        scripts: {
          dev: "ts-node-dev --respawn src/index.ts",
          build: "tsc",
          start: "node dist/index.js",
        },
        dependencies: {
          express: "^4.19.0",
        },
        devDependencies: {
          typescript: "^5.6.0",
          "@types/node": "^20.14.0",
          "@types/express": "^4.17.21",
          "ts-node-dev": "^2.0.0",
        },
      },
      null,
      2
    )
  );

  // tsconfig
  tree = addFile(
    tree,
    "tsconfig.json",
    JSON.stringify(
      {
        compilerOptions: {
          target: "ES2020",
          module: "commonjs",
          outDir: "dist",
          rootDir: "src",
          strict: true,
          esModuleInterop: true,
        },
        include: ["src"],
      },
      null,
      2
    )
  );

  // README â€“ dev guide
  tree = addFile(
    tree,
    "README.md",
    `# ${name}

${description}

This service was generated by **Platform Studio â€“ Service Factory**. It includes a standard Node.js + TypeScript layout
and optional platform features such as auth, metrics, tests, observability, containers, and service clients,
depending on what was enabled at generation time.

---

## 1. Prerequisites

- Node.js 18+ (Node 20 recommended)
- npm 8+ (or compatible package manager)
- (Optional) Docker, if you plan to run the service as a container
- (Optional) Kafka or another event bus, if event-bus support was enabled

---

## 2. Getting Started

After unzipping this scaffold:

\`\`\`bash
# install dependencies
npm install

# run in dev mode (TypeScript)
npm run dev

# build for production
npm run build

# run compiled build (after build)
npm start
\`\`\`

By default, the service exposes:

- \`GET /health\` â†’ basic health check (root-level)
- \`GET /api/v1/health\` â†’ API health endpoint via controller

If metrics, dashboard, or docs were enabled during generation, you may also have:

- \`GET /metrics\` â€“ Prometheus metrics
- \`GET /dashboard\` â€“ simple observability dashboard
- \`GET /docs\` â€“ Swagger UI for the OpenAPI spec
- \`GET /\` â€“ landing page redirecting to \`/docs\`

---

## 3. Project Structure

\`\`\`text
${name}/
  package.json          # dependencies & scripts
  tsconfig.json         # TypeScript compiler config
  openapi/              # OpenAPI definitions (if enabled)
    openapi.yaml
  src/
    index.ts            # main entrypoint â€“ wires middleware & routes
    config/             # configuration modules (logging, metrics, jwt, etc.)
    api/
      v1/
        routes.ts       # API route registration
        controllers/
          HealthController.ts
          ExampleController.ts
    infra/              # infrastructure adapters (event bus, http clients, db, ...)
    clients/            # generated service-to-service HTTP clients (if enabled)
  test/                 # Jest tests (if test plugin enabled)
    unit/
    api/
  .github/
    workflows/
      ci.yml            # CI pipeline (if CI/CD plugin enabled)
  Dockerfile            # container build (if containerization plugin enabled)
  deploy/
    kubernetes.yaml     # k8s deployment template (if containerization plugin enabled)
\`\`\`

> **Important:** Your **core service logic** should live in:
> - \`src/api/v1/controllers/*\` â€“ API handlers
> - \`src/domain/*\` â€“ domain / business rules (you can create this folder)
> - optionally separating domain from infrastructure (ports & adapters).

---

## 4. Where to Write Your Core Logic

1. **Add or extend controllers**

   Edit or add files under:

   - \`src/api/v1/controllers/\`

   For example, you might extend:

   - \`src/api/v1/controllers/ExampleController.ts\`

   and wire additional routes in \`src/api/v1/routes.ts\`.

2. **Put domain rules in a dedicated layer (recommended)**

   Create a \`src/domain/\` folder and add your core logic there:

   - \`src/domain/invoices/createInvoice.ts\`
   - \`src/domain/invoices/calculateTotals.ts\`

   Controllers should be thin and delegate to these domain functions.

3. **Use platform services instead of re-inventing them**

   - Logging: use the provided logger (if logging plugin enabled).
   - Metrics: record custom metrics using the configured registry (if metrics enabled).
   - Event bus: publish events through the provided event bus wrapper (if enabled).
   - HTTP clients: use generated clients in \`src/clients/*\` to call other services (if enabled).

---

## 5. Testing & CI

If you enabled **Automated tests**, the scaffold includes:

- Jest configuration: \`jest.config.cjs\`
- Example tests under \`test/unit\`

Run tests locally:

\`\`\`bash
npm test
\`\`\`

If you also enabled **CI/CD workflow**, there is a GitHub Actions pipeline at:

- \`.github/workflows/ci.yml\`

It runs on pushes and pull requests to \`main\`:

- \`npm ci\`
- \`npm test\`
- \`npm run build\`

Push this repo to GitHub and CI will automatically validate the service.

---

## 6. OpenAPI & Swagger (API Documentation)

If OpenAPI/Swagger was enabled:

- The main spec file is at: \`openapi/openapi.yaml\`
- At runtime, the service loads this spec and serves:

  - \`GET /docs\` â€“ Swagger UI
  - \`GET /\` â€“ redirect to \`/docs\` for a simple landing page

To document new endpoints:

1. Update the OpenAPI file under \`openapi/openapi.yaml\` to include your new routes.
2. Keep the handlers in \`src/api/v1/controllers\` in sync with the spec.
3. Restart the dev server if needed.

---

## 7. Containers & Deployment

If containerization was enabled, the scaffold includes:

- \`Dockerfile\` â€“ multi-stage Node.js build
- \`deploy/kubernetes.yaml\` â€“ example Kubernetes deployment & service

### Build & run locally with Docker

\`\`\`bash
# build image
docker build -t ${name}:local .

# run container
docker run --rm -p 3000:3000 ${name}:local
\`\`\`

Then open \`http://localhost:3000/health\` (and \`/docs\` or \`/dashboard\` if enabled).

---

## 8. Event Bus & Service Clients (If Enabled)

If **event bus** support was enabled:

- Configuration under: \`src/config/eventBus.ts\`
- Wrapper class: \`src/infra/eventBus.ts\`

Publish an event from your handlers or domain services via:

\`\`\`ts
// example usage (you'll need to inject the EventBus instance)
await eventBus.publish("your.topic.name", { /* payload */ });
\`\`\`

If **service clients** were enabled:

- Generic HTTP client infra: \`src/infra/httpClient.ts\`
- One client per downstream service: \`src/clients/*Client.ts\`

Use them from controllers / services to call other APIs instead of hand-rolling HTTP calls.

---

## 9. Next Steps

- Add your core business endpoints under \`src/api/v1/controllers\`.
- Model your domain under \`src/domain\`.
- Keep \`openapi/openapi.yaml\` in sync with your API.
- Extend metrics, logging, and observability as your needs grow.

Happy building! ðŸš€
`
  );

  // src/index.ts with API routes + plugin markers
  const indexTs = `import express from "express";

// PLATFORM_IMPORTS
import { registerRoutesV1 } from "./api/v1/routes";
import morgan from "morgan";
import path from "path";

const app = express();


// Core middleware
app.use(express.json());
app.use(morgan("dev"));

// Serve static landing page (we'll add src/public/index.html below)
app.use(express.static(path.join(__dirname, "public")));


// PLATFORM_MIDDLEWARE

// Root health for load balancers / platform checks
app.get("/health", (_req, res) => {
  return res.json({ status: "ok" });
});

// Mount versioned API routes
app.use("/api/v1", registerRoutesV1());

// PLATFORM_ROUTES
const port = process.env.PORT || 3000;

// PLATFORM_STARTUP

app.listen(port, () => {
  console.log("${name} listening on port", port);
});
`;

  tree = addFile(tree, "src/index.ts", indexTs);

  // ---- Add base API routes + controllers ----

  // routes.ts
  tree = addFile(
    tree,
    "src/api/v1/routes.ts",
    `import { Router } from "express";
import { HealthController } from "./controllers/HealthController";
import { ExampleController } from "./controllers/ExampleController";

export function registerRoutesV1() {
  const router = Router();

  const healthController = new HealthController();
  const exampleController = new ExampleController();

  // Health endpoint for API version 1
  router.get("/health", healthController.get);

  // Example CRUD-style endpoints (in-memory demo)
  router.get("/examples", exampleController.list);
  router.post("/examples", exampleController.create);

  return router;
}
`
  );

  // HealthController.ts
  tree = addFile(
    tree,
    "src/api/v1/controllers/HealthController.ts",
    `import { Request, Response } from "express";

export class HealthController {
  get(_req: Request, res: Response) {
    return res.json({ status: "ok", scope: "api/v1" });
  }
}
`
  );

  // ExampleController.ts â€“ simple in-memory example to show "where to code"
  tree = addFile(
    tree,
    "src/api/v1/controllers/ExampleController.ts",
    `import { Request, Response } from "express";

interface ExampleItem {
  id: string;
  name: string;
}

// In-memory storage just for demonstration. Replace with real storage / domain layer.
const examples: ExampleItem[] = [];

export class ExampleController {
  list(_req: Request, res: Response) {
    return res.json(examples);
  }

  create(req: Request, res: Response) {
    const name = (req.body && req.body.name) || "example";
    const item: ExampleItem = {
      id: Date.now().toString(),
      name,
    };
    examples.push(item);
    return res.status(201).json(item);
  }
}
`
  );

  return tree;
}
